{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\n * Options type.\n */\ntype OptionsType = {\n    /**\n     * The space between bottom of the {@link https://developer.mozilla.org/en-US/docs/Glossary/Viewport|viewport} and bottom of the `visible area`.\n     * @default 0\n     */\n    spaceBottom?: number;\n    /**\n     * The space between top of the {@link https://developer.mozilla.org/en-US/docs/Glossary/Viewport|viewport} and top of the `visible area`.\n     * @default 0\n     */\n    spaceTop?: number;\n    /**\n     * Default {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position|position} for the target `element`.\n     * @default ''\n     */\n    position?: CSSStyleDeclaration['position'];\n};\n\n/**\n * The element coordinates.\n */\ntype TypeElementCoords = {\n    left: number;\n    top: number;\n};\n\n/**\n * Indexes of events in the events array.\n */\nenum Item {\n    Resize = 0,\n    Scroll = 1,\n}\n\nenum Event {\n    None,\n    Resize,\n    Scroll,\n}\n\n/**\n * Defines `viewport` direction.\n */\nenum Direction {\n    Down,\n    None,\n    Up,\n}\n\n/**\n * Strategy.\n */\nenum Strategy {\n    /**\n     * Sticky both sides by Y-axis.\n     */\n    Both,\n    /**\n     * Nothing do.\n     */\n    None,\n    /**\n     * Sticky only top side.\n     */\n    Top,\n}\n\n/**\n * @enum {number} Position variant of target `element`.\n */\nenum State {\n    /**\n     * Element affixed at the bottom of the container.\n     */\n    ContainerBottom,\n    /**\n     * Element fixed at the top of the window viewport area (including top padding).\n     */\n    ColliderTop,\n    /**\n     * Element fixed at the bottom of the window viewport area (including bottom padding).\n     */\n    ColliderBottom,\n    /**\n     * Default element behavior. Case without specific rules.\n     */\n    None,\n    /**\n     * The element is offset along the Y axis relative to the container.\n     */\n    TranslateY,\n    /**\n     * Indicates that rendering should be skipped until the state changes.\n     */\n    Rest,\n}\n\ntype Rules = Pick<CSSStyleDeclaration, 'width' | 'left' | 'top' | 'position' | 'transform'>;\n\n/**\n * stick-n-roll - helps to give an element sticky scrolling capability.\n * @version 1.0.6\n * @link https://github.com/devashtar/stick-n-roll\n * @author devashtar <omg.michael.here@gmail.com>\n * @license The MIT License (MIT)\n */\nexport class StickNRoll {\n    /**\n     * Parent element of target {@link element}.\n     */\n    private container: HTMLElement;\n\n    /**\n     * Target element with sticky and scroll abilities.\n     */\n    private element: HTMLElement;\n\n    /**\n     * Triggered Event.\n     */\n    private events: [Event.Resize | Event.None, Event.Scroll | Event.None];\n\n    /**\n     * Indicates that a render request has already been initiated.\n     * @default false\n     */\n    private isRunningRequest: boolean;\n\n    /**\n     * The Current Y-axis coordinates relative to the {@link container}.\n     */\n    private translateY: number;\n\n    /**\n     * The maximum allowed Y-axis coordinates relative to the {@link container}.\n     */\n    private maxTranslateY: number;\n\n    /**\n     * Previous element height.\n     */\n    private prevElementHeight: number;\n\n    /**\n     * Height of the {@link container}.\n     */\n    private containerHeight: number;\n\n    /**\n     * Width of the {@link container}.\n     */\n    private containerWidth: number;\n\n    /**\n     * Coordinate by X-axis of the {@link container}.\n     */\n    private containerLeft: number;\n\n    /**\n     * Coordinate by Y-axis of the {@link container}.\n     */\n    private containerTop: number;\n\n    /**\n     * Previous width of the {@link container}.\n     */\n    private prevContainerWidth: number;\n\n    /**\n     * Previous coordinate by X-axis of the {@link container}.\n     */\n    private prevContainerLeft: number;\n\n    /**\n     * Previous coordinate by Y-axis of the {@link container}.\n     */\n    private prevContainerTop: number;\n\n    /**\n     * Height of the {@link collider}.\n     */\n    private colliderHeight: number;\n\n    /**\n     * Top coordinate of the {@link collider}.\n     */\n    private colliderTop: number;\n\n    /**\n     * Previous top coordinate of the {@link collider}.\n     */\n    private prevColliderTop: number;\n\n    /**\n     * Previous coordinate by X-axis of the {@link https://developer.mozilla.org/en-US/docs/Glossary/Viewport|viewport}.\n     */\n    private prevViewportScrollX: number;\n\n    /**\n     * Previous coordinate by Y-axis of the {@link https://developer.mozilla.org/en-US/docs/Glossary/Viewport|viewport}.\n     */\n    private prevViewportScrollY: number;\n\n    /**\n     * Space top.\n     * @default 0\n     */\n    private spaceTop: number;\n\n    /**\n     * Previous space top.\n     * @default 0\n     */\n    private prevSpaceTop: number;\n    \n    /**\n     * Space bottom.\n     * @default 0\n     */\n    private spaceBottom: number;\n\n    /**\n     * Previous space bottom.\n     * @default 0\n     */\n    private prevSpaceBottom: number;\n\n    /**\n     *  Resize observer.\n     */\n    private resizeObserver: ResizeObserver;\n\n    /**\n     * Current strategy. Helps to detect element behaviour.\n     * @default Strategy.None\n     */\n    private strategy: Strategy;\n\n    /**\n     * Previous strategy.\n     * @default Strategy.None\n     */\n    private prevStrategy: Strategy;\n\n    /**\n     * Previous state.\n     * @default Variant.None\n     */\n    private prevState: State;\n\n    /**\n     * List of available CSS properties.\n     */\n    private listOfRules: Rules;\n\n    /**\n     * List of css properties to be updated.\n     */\n    private rules: Partial<Rules>;\n\n    /**\n     * @param {HTMLElement} container - The parent element ({@link container}) of {@link element}.\n     * @param {HTMLElement} element - The target {@link element} which will be endowed with stickiness and scrolling abilities relative to its parent element ({@link container}).\n     */\n    constructor(container: HTMLElement, element: HTMLElement, options?: OptionsType) {\n        this.container = container;\n        this.element = element;\n\n        this.isRunningRequest = false;\n\n        this.colliderHeight = 0;\n        this.colliderTop = 0;\n        this.prevColliderTop = 0;\n\n        this.containerHeight = 0;\n        this.containerWidth = 0;\n        this.containerLeft = 0;\n        this.containerTop = 0;\n        this.prevContainerWidth = 0;\n        this.prevContainerLeft = 0;\n        this.prevContainerTop = 0;\n\n        this.prevElementHeight = 0;\n\n        this.maxTranslateY = 0;\n        this.translateY = 0;\n\n        this.prevViewportScrollX = 0;\n        this.prevViewportScrollY = 0;\n\n        this.events = [Event.None, Event.None];\n\n        this.strategy = Strategy.None;\n        this.prevStrategy = Strategy.None;\n\n        this.prevState = State.None;\n\n        this.listOfRules = { width: '', left: '', top: '', position: options?.position ?? '', transform: '' };\n        this.rules = {};\n\n        this.spaceBottom = options?.spaceBottom ?? 0;\n        this.prevSpaceBottom = options?.spaceBottom ?? 0;\n        this.spaceTop = options?.spaceTop ?? 0;\n        this.prevSpaceTop = options?.spaceTop ?? 0;\n\n        // Binds \"this\" context to the following class methods.\n        this._calcDims = this._calcDims.bind(this);\n        this._calcScroll = this._calcScroll.bind(this);\n        this._resizeListener = this._resizeListener.bind(this);\n        this._scrollListener = this._scrollListener.bind(this);\n\n        // Create resize observer.\n        this.resizeObserver = new ResizeObserver(this._resizeListener);\n    }\n\n    /**\n     * Enable sticky scrolling capability. Use {@link disable} method to deactivate sticky scrolling capability.\n     */\n    public enable(): void {\n        this._addListeners(); // calls _calcDims method by default, cause is used ResizeObserver\n    }\n\n    /**\n     * Disable sticky scrolling capability. Use {@link enable} method to activate sticky scrolling capability again.\n     */\n    public disable(): void {\n        this._removeListeners();\n        this.isRunningRequest = false;\n        this.events.fill(Event.None);\n    }\n\n    /**\n     *  Update {@link spaceBottom} and {@link spaceTop}. It fires the render after changes of spaces.\n     */\n    public updateSpaces(spaces: Pick<OptionsType, 'spaceBottom' | 'spaceTop'>): void {\n        this.spaceBottom = spaces.spaceBottom ?? 0;\n        this.spaceTop = spaces.spaceTop ?? 0;\n        this._resizeListener();\n    }\n\n    /**\n     * Resize listener.\n     */\n    private _resizeListener(): void {\n        if (this.events[Item.Resize] === Event.None) this.events[Item.Resize] = Event.Resize;\n        this._request();\n    }\n\n    /**\n     * Scroll listener.\n     */\n    private _scrollListener(): void {\n        if (this.events[Item.Scroll] === Event.None) this.events[Item.Scroll] = Event.Scroll;\n        this._request();\n    }\n\n    /**\n     * Get coordinates for passed element.\n     */\n    private _getCoords(element: HTMLElement): TypeElementCoords {\n        const coords = { left: element.offsetLeft, top: element.offsetTop };\n        while (((element as unknown) = 'BODY' === element.tagName ? element.parentElement : element.offsetParent)) {\n            coords.top += element.offsetTop;\n            coords.left += element.offsetLeft;\n        }\n        return coords;\n    }\n\n    /**\n     * Update styles in target {@link element} and {@link container}.\n     */\n    private _render(state: State): void {\n        if (state === State.ContainerBottom) {\n            this.translateY = this.maxTranslateY;\n            this.rules = {\n                top: this.spaceTop + 'px',\n                left: '0px',\n                position: 'sticky',\n                width: this.container.clientWidth + 'px',\n            };\n        } else if (state === State.ColliderBottom) {\n            this.translateY = 0;\n            this.rules = {\n                top: this.colliderHeight + this.spaceTop - this.element.offsetHeight + 'px',\n                left: this.containerLeft - window.scrollX + 'px',\n                position: 'fixed',\n                width: this.container.clientWidth + 'px',\n            };\n        } else if (state === State.ColliderTop) {\n            this.translateY = 0;\n            this.rules = {\n                top: this.spaceTop + 'px',\n                left: this.containerLeft - window.scrollX + 'px',\n                position: 'fixed',\n                width: this.container.clientWidth + 'px',\n            };\n        } else if (state === State.None) {\n            this.translateY = 0;\n            this.rules = {};\n        } else if (state === State.TranslateY) {\n            if (this.prevState === State.ColliderTop) {\n                this.translateY = this.prevColliderTop - this.containerTop;\n            } else if (this.prevState === State.ColliderBottom) {\n                this.translateY = this.prevColliderTop + this.colliderHeight - this.containerTop - this.prevElementHeight;\n            } else if (this.prevState === State.ContainerBottom) {\n                this.translateY = this.containerHeight - this.element.offsetHeight;\n            }\n            this.rules = { position: 'relative', transform: `translate3d(0px, ${this.translateY}px, 0px)` };\n        }\n\n        this.container.style.position = state === State.ContainerBottom ? 'relative' : '';\n\n        for (const key in this.listOfRules) {\n            this.element.style[key as keyof Rules] =\n                this.rules[key as unknown as keyof Rules] ?? this.listOfRules[key as unknown as keyof Rules];\n        }\n    }\n\n    /**\n     * Get the scroll direction. `None` for horizontal scrolling or no scrolling.\n     */\n    private _getDirection(): Direction {\n        if (this.prevViewportScrollY === window.scrollY) return Direction.None;\n        return this.prevViewportScrollY < window.scrollY ? Direction.Down : Direction.Up;\n    }\n\n    /**\n     * Get state of target element.\n     */\n    private _getState(direction: Direction): State {\n        if (this.prevState === State.ColliderTop) {\n            if (this.colliderTop <= this.containerTop) {\n                return State.None;\n            }\n            if (this.colliderTop + this.element.offsetHeight >= this.containerTop + this.containerHeight) {\n                return State.ContainerBottom;\n            }\n            if (this.prevStrategy === Strategy.Top && this.element.offsetHeight > this.colliderHeight) {\n                this.prevStrategy = this.strategy;\n                return State.TranslateY;\n            }\n            if (this.strategy === Strategy.Both && direction === Direction.Down) {\n                return State.TranslateY;\n            }\n            if (\n                this.prevViewportScrollX !== window.scrollX ||\n                this.prevContainerLeft !== this.containerLeft ||\n                this.prevContainerWidth !== this.containerWidth ||\n                this.prevContainerTop !== this.containerTop ||\n                this.prevSpaceBottom !== this.spaceBottom ||\n                this.prevSpaceTop !== this.spaceTop\n            ) {\n                return State.ColliderTop;\n            }\n        } else if (this.prevState === State.ColliderBottom) {\n            if (this.colliderTop <= this.containerTop) {\n                return State.None;\n            }\n            if (this.colliderTop + this.colliderHeight >= this.containerTop + this.containerHeight) {\n                return State.ContainerBottom;\n            }\n            if (this.element.offsetHeight <= this.colliderHeight) {\n                return State.ColliderTop;\n            }\n            if (direction === Direction.Up || this.prevElementHeight !== this.element.offsetHeight) {\n                return State.TranslateY;\n            }\n            if (\n                this.prevViewportScrollX !== window.scrollX ||\n                this.prevContainerLeft !== this.containerLeft ||\n                this.prevContainerWidth !== this.containerWidth ||\n                this.prevContainerTop !== this.containerTop ||\n                this.prevSpaceBottom !== this.spaceBottom ||\n                this.prevSpaceTop !== this.spaceTop\n            ) {\n                return State.ColliderBottom;\n            }\n        } else if (this.prevState === State.ContainerBottom) {\n            if (this.colliderTop <= this.containerTop) {\n                return State.None;\n            }\n            if (direction === Direction.Up && this.colliderTop <= this.containerTop + this.maxTranslateY) {\n                return State.ColliderTop;\n            }\n            if (this.element.offsetHeight < this.containerTop + this.containerHeight - this.colliderTop) {\n                return State.ColliderTop;\n            }\n            if (this.prevContainerWidth !== this.containerWidth) {\n                return State.ContainerBottom;\n            }\n        } else if (this.prevState === State.None) {\n            if (this.colliderTop + this.element.offsetHeight >= this.containerTop + this.containerHeight) {\n                return State.ContainerBottom;\n            }\n            if (this.element.offsetHeight < this.colliderHeight && this.colliderTop >= this.containerTop) {\n                return State.ColliderTop;\n            }\n            if (\n                this.strategy === Strategy.Both &&\n                this.colliderTop + this.colliderHeight >= this.containerTop + this.element.offsetHeight\n            ) {\n                return State.ColliderBottom;\n            }\n        } else if (this.prevState === State.TranslateY) {\n            if (this.containerHeight - this.translateY < this.element.offsetHeight) {\n                return State.ContainerBottom;\n            }\n            if (this.element.offsetHeight < this.colliderHeight || this.colliderTop <= this.containerTop + this.translateY) {\n                return State.ColliderTop;\n            }\n            if (\n                this.translateY < this.maxTranslateY &&\n                this.colliderTop + this.colliderHeight > this.containerTop + this.translateY + this.element.offsetHeight\n            ) {\n                return State.ColliderBottom;\n            }\n        }\n\n        return State.Rest;\n    }\n\n    /**\n     * Get a {@link strategy} that determines the further behavior of the target {@link element}.\n     */\n    private _getStrategy(): Strategy {\n        if (this.containerHeight <= this.element.offsetHeight) return Strategy.None;\n        if (this.colliderHeight < this.element.offsetHeight) return Strategy.Both;\n        return Strategy.Top;\n    }\n\n    /**\n     * Calculate {@link https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements|dimensions}.\n     */\n    private _calcDims(): void {\n        const containerCoords = this._getCoords(this.container);\n        this.containerLeft = containerCoords.left;\n        this.containerTop = containerCoords.top;\n        this.containerHeight = this.container.clientHeight;\n        this.containerWidth = this.container.clientWidth;\n        this.colliderHeight = window.innerHeight - this.spaceTop - this.spaceBottom;\n        this.maxTranslateY = this.container.clientHeight - this.element.offsetHeight;\n\n        this.strategy = this._getStrategy();\n\n        if (this.strategy === Strategy.None) {\n            if (this.prevStrategy !== this.strategy) this._render(State.None);\n        } else {\n            this._calcScroll();\n        }\n\n        this.prevContainerWidth = this.containerWidth;\n        this.prevContainerLeft = this.containerLeft;\n        this.prevContainerTop = this.containerTop;\n        this.prevElementHeight = this.element.offsetHeight;\n        this.prevStrategy = this.strategy;\n        this.prevSpaceBottom = this.spaceBottom;\n        this.prevSpaceTop = this.spaceTop;\n    }\n\n    /**\n     * Calculate {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSSOM_view/Coordinate_systems|coordinates}.\n     */\n    private _calcScroll(): void {\n        this.colliderTop = window.scrollY + this.spaceTop;\n\n        const state = this._getState(this._getDirection());\n\n        if (state !== State.Rest) {\n            this._render(state);\n            this.prevState = state;\n        }\n        \n        this.prevColliderTop = this.colliderTop;\n        this.prevViewportScrollX = window.scrollX;\n        this.prevViewportScrollY = window.scrollY;\n    }\n\n    /**\n     * Helps apply DOM manipulation and synchronize processing with rendering. See {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame|requestAnimationFrame}.\n     */\n    private _request(): void {\n        if (this.isRunningRequest) return;\n        this.isRunningRequest = true;\n        window.requestAnimationFrame(() => {\n            if (this.events[Item.Resize] === Event.Resize) {\n                this.events[Item.Resize] = Event.None;\n                this._calcDims();\n            } else if (this.events[Item.Scroll] === Event.Scroll) {\n                this.events[Item.Scroll] = Event.None;\n                this._calcScroll();\n            }\n            this.isRunningRequest = false;\n        });\n    }\n\n    /**\n     * Observe {@link https://developer.mozilla.org/en-US/docs/Web/API/Node|nodes} from target {@link element} to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/body|document body} with help the {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver|ResizeObserver}.\n     */\n    private _observeTreeNodesFromCurrentToBody(element: HTMLElement): void {\n        while (element) {\n            this.resizeObserver.observe(element);\n            if (element.tagName === 'BODY') break;\n            (element as unknown) = element.parentElement;\n        }\n    }\n\n    /**\n     * Add required event listeners. See {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener|addEventListener} and {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver|ResizeObserver}.\n     */\n    private _addListeners(): void {\n        window.addEventListener('scroll', this._scrollListener, { capture: false, passive: true });\n        this._observeTreeNodesFromCurrentToBody(this.element);\n    }\n\n    /**\n     * Remove all event listeners. See {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener|removeEventListener} and {@link https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver|ResizeObserver}.\n     */\n    private _removeListeners(): void {\n        window.removeEventListener('scroll', this._scrollListener, { capture: false }); // window\n        this.resizeObserver.disconnect();\n    }\n}\n\nexport default StickNRoll;"],"mappings":"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","names":["index_exports","__export","StickNRoll","index_default","__toCommonJS","StickNRoll","container","element","options","spaces","coords","state","key","direction","containerCoords","index_default"]}